---
marp: true
theme: default
author: Nirand Pisutha-Arnond
paginate: true
footer: "255499: Web Application Development for IE"
---

<style>
@import url('https://fonts.googleapis.com/css2?family=Prompt:ital,wght@0,100;0,300;0,400;0,700;1,100;1,300;1,400;1,700&display=swap');

:root {
    font-family: Prompt;
    --hl-color: #D57E7E;
}

h1 {
  font-family: Prompt;
}
</style>

# Web Application Development for Industrial Engineers

## การพัฒนาเวปแอปพลิเคชันสำหรับวิศวกรอุตสาหการ

---

# Asynchronous Programming

---

# Motivation

- Normally, a given program's code runs straight along, with only one thing happening at once.
- If a function relies on the result of another function, it has to wait for the other function to finish and return.
  - And until that happens, the entire program is essentially stopped from the perspective of the user.
- This is **synchronous programming**.

---

# Motivation

- synchronicity can lead to frustrating experience for a user.
- Also it might not be a good use of computer processing power.
  - Computers have multiple processor cores available.
  - We should let the other task get processed on another processor core and let us know when it's done.
- This is the basis of **asynchronous programming**.

---

# Environment

- It is up to the programming environment you are using (web browsers, in the case of web development) to provide you with APIs that allow you to run such tasks asynchronously.

---

# Synchronous JavaScript

- A lot of the functionality we have larned are synchronous.

---

```html
<button>Click me</button>
```

```javascript
const btn = document.querySelector("button");
btn.addEventListener("click", () => {
  alert("You clicked me!");

  let pElem = document.createElement("p");
  pElem.textContent = "This is a newly-added paragraph.";
  document.body.appendChild(pElem);
});
```

---

# Blocking code

- When a web app runs in a browser and it executes an intensive chunk of code without returning control to the browser, the browser can appear to be frozen.
- This is called **blocking**.

---

```javascript
const btn = document.querySelector("button");
btn.addEventListener("click", () => {
  // Expensive calculations
  let myDate;
  for (let i = 0; i < 10000000; i++) {
    let date = new Date();
    myDate = date;
  }
  console.log(myDate);
  // -->

  let pElem = document.createElement("p");
  pElem.textContent = "This is a newly-added paragraph.";
  document.body.appendChild(pElem);
});
```

---

# Side note: thread

- JavaScript, generally speaking, is **single-threaded**.
- A thread is basically a single process that a program can use to complete tasks. Each thread can only do a single task at once.
- Even with multiple cores, you could only get it to run tasks on a single thread, called the **main thread**.

---

# What happened?

- The code above contains all synchronous tasks.
- Tasks are executed sequentially.

```
Main Thread: Task A --> Task B --> Task C --> Task D ...
```

---

# Asynchronous javascript

```javascript
setTimeout(() => alert("I waited."), 3000);
```

---

```javascript
const btn = document.querySelector("button");
btn.addEventListener("click", () => {
  // Asynchronous feature
  setTimeout(() => alert("I waited."), 3000);

  let pElem = document.createElement("p");
  pElem.textContent = "This is a newly-added paragraph.";
  document.body.appendChild(pElem);
});
```

---

# What happened?

- `setTimeout` cause the "task" (callback function) be to asynchronous.

```
Main Thread: Fire Handler --(Skip alert)--> Show paragraph --(After 3 seconds)--> Show alert.
```
